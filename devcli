#!/usr/bin/env bash

MAIN_COMMAND_VERSION="0.8"

MAIN_COMMAND=$(basename ${0})
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}" )" > /dev/null && pwd)"
PROJECTS_DIR="$(cd ${ROOT_DIR}/.. && pwd)"

function _color()     { tput -Txterm setaf ${1}; echo -e ${2}; tput -Txterm sgr0; }
function in_red()     { _color 1 "${1}"; } # use for failures
function in_green()   { _color 2 "${1}"; } # use for successes
function in_yellow()  { _color 3 "${1}"; } # use for warnings / attention
function in_magenta() { _color 5 "${1}"; } # use for debug messages
function in_cyan()    { _color 6 "${1}"; } # use for main actions / progress

# will evaluate if there's a env variable in the
# form of MAIN_COMMAND_SUFFIX, if defined
# will return its value otherwise default
# will be returned.
# This is not the same as ${VAR:-DEFAULT} because
# VAR is dynamic. If the command line gets renamed
# these are supposed to keep working regarless
function dyn_value() {
  local suffix="${1}"
  local default="${2}"
  v=$(eval "echo -n \${${MAIN_COMMAND^^}_${suffix}}")
  [[ -n ${v} ]] && echo ${v} || echo ${default}
}

# Variables that can be overriden by the environment:
# CONFIGURATION_DIR points to where "load_conf" will look
# SUBCOMMANDS_DIR is the main dir where commands are load from
# DEBUG is turn on or off debug messages.
CONFIGURATION_DIR=$(dyn_value "CONF_DIR" "${ROOT_DIR}/conf")
SUBCOMMANDS_DIR=$(dyn_value "SUBCMD_DIR" "${ROOT_DIR}/${MAIN_COMMAND}.d")
DEBUG=$(dyn_value "DEBUG" "")

# log functions should be defined as soon as possible
# so it become available for other functions
function log() {
  if [[ -n ${DEBUG} ]]; then
    tput -Txterm setaf 5 >&2
    echo -e "debug: ${*}" >&2
    tput -Txterm sgr0 >&2
  fi
}

# This is a shortcut for exiting with error
# calling error will stop the script
function error() {
  in_red "ERROR: ${1}"
  exit 1
}

# This is a shortcut for warning messages,
# these won't stop the execution of the script
function warn() {
  in_yellow "WARN: ${1}"
}

function use() {
  local lib="${SUBCOMMANDS_DIR}/_${1}"
  log "requiring library: ${lib}"
  [[ -f ${lib} ]] && source ${lib} || error "Library '${lib}' not found"
}

function load_conf() {
  local conf="${CONFIGURATION_DIR}/${SUBCOMMAND}/${1}"
  log "loading configuration: ${conf}"
  [[ -f ${conf} ]] && source ${conf} || error "Configuration '${conf}' not found"
}

# warn users of outdated bash versions
if [[ ${BASH_VERSION%%.*} -lt 4 ]]; then
  warn "bash version is '${BASH_VERSION}'"
  warn "Consider installing bash 4 or newer."
  warn "Syntax errors and/or wrong behavior can occur"
  warn "under outdated versions of bash."
fi

# add itself to PATH if needed
log "check if ${MAIN_COMMAND} is on PATH"
type -a ${MAIN_COMMAND} &> /dev/null
if [[ $? -ne 0 ]]; then
  export PATH=${PATH}:${ROOT_DIR}
fi

# environment settings that depend on a project
[[ -f ${SUBCOMMANDS_DIR}/_environment ]] && . ${SUBCOMMANDS_DIR}/_environment

###########################
# internal functions bellow

# Lists all subcommands ignoring those with a leading "_"
# which are libraries
function _list_commands() {
  cat <<EOU
  usage: ${MAIN_COMMAND} [-h|-?|--help|help] [-l] [--version] [SUBCOMMAND]

  -h|-?|--help|help            Show this help message
  -l                           List available libraries
  --version                    Display current version

  Subcommands available ('${MAIN_COMMAND} SUBCOMMAND' for usage):

EOU
  for i in $(export LC_COLLATE=C; find ${SUBCOMMANDS_DIR} -maxdepth 1 -type f -or -type l | grep -vE '/_[^[:blank:]]+$' | sort); do
    source "${i}"
    local libname=$(basename ${i})
    printf "  %.24s %-60s\n" \
       "${libname}                                          " \
       "${SUBCOMMAND_DESC}"
  done
  echo
  exit 1
}

# List only libraries and ignore commands, this is
# the opposite of _list_commands()
function _list_libraries() {
  cat <<EOU

  Libraries available ('${MAIN_COMMAND} LIBRARY' for more information):

EOU
  for i in $(export LC_COLLATE=C; ls ${SUBCOMMANDS_DIR}/* | grep -E '/_[^[:blank:]]+$' | sort); do
    source "${i}"
    local libname=$(basename ${i})
    printf "  %.24s %-60s\n" \
       "${libname}                                          " \
       "${SUBCOMMAND_DESC}"
  done
  echo
  exit 1
}

function _subcommand_help() {
  local subcmd=${1}
  local subhelp=${2}
  cat <<EOU

  Showing '${MAIN_COMMAND} ${subcmd}' available actions:

  ${subhelp}

EOU
  exit 1
}

function _help() {
  _subcommand_help ${SUBCOMMAND} "${SUBCOMMAND_HELP}"
}

function _handle_subcommand() {
  local SUBCOMMAND=${1}; shift 1
  local ACTION="${@}"

  log "running ${SUBCOMMANDS_DIR}/${SUBCOMMAND} ${ACTION} "
  . "${SUBCOMMANDS_DIR}/${SUBCOMMAND}" ${ACTION}

  if [[ "${ACTION}" == "help" || -z "${ACTION}" ]]; then
    log "showing '${SUBCOMMAND}' help"
    _help
  fi
}

_arg_subcmd=${1}
log "got argument '${_arg_subcmd}'"
case ${_arg_subcmd} in
  -l)
    log 'showing available libs'
    _list_libraries
  ;;
  help|-h|-?|--help|'')
    log 'help or no argument was given'
    _list_commands
  ;;
  --version)
    echo "${MAIN_COMMAND} ${MAIN_COMMAND_VERSION}"
  ;;
  *)
    log "arguments '${*}'"
    log "checking if '${SUBCOMMANDS_DIR}/${_arg_subcmd}' exists"
    [[ ! -f "${SUBCOMMANDS_DIR}/${_arg_subcmd}" ]] && in_red "'${_arg_subcmd}' not found" && _list_commands
    shift 1
    _handle_subcommand ${_arg_subcmd} "${@}"
    ;;
esac
